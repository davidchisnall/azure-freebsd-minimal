// Copyright David Chisnall
// SPDX-License-Identifier: MIT
#define CONFIG_DETAIL_NAMESPACE
#define CONFIG_NAMESPACE_BEGIN                                                 \
	namespace                                                                  \
	{
#define CONFIG_NAMESPACE_END }
#include "config.h"
#include "mini_http.hh"
#include <getopt.h>

namespace
{
	/**
	 * Class encapsulating Azure Instance Metadata.  Owns the data received
	 * from the networks and uses classes generated by the config-gen tool to
	 * expose the data.
	 */
	class AzureInstanceMetadata
	{
		/**
		 * The data read from the network.
		 */
		std::vector<char> data;

		/**
		 * The type used for the parsed object.
		 */
		AzureInstance m{nullptr};

		public:
		/**
		 * Construct an Azure Instance Metadata object by fetching the data
		 * from the server.
		 */
		AzureInstanceMetadata()
		{
			HTTPClient con{"169.254.169.254"};
			std::array<std::pair<const char *, const char *>, 1> header{
			  std::make_pair("Metadata", "true")};
			con.get("/metadata/instance?api-version=2021-02-01", header)(
			  [&](auto &buffer) { data = std::move(buffer); },
			  [&](const HTTPClient::HTTPError &err) {
				  std::cerr << "Error fetching metadata " << err.error_code
				            << " " << err.error_message << std::endl;
				  exit(EXIT_FAILURE);
			  });
			struct ucl_parser *p = ucl_parser_new(
			  UCL_PARSER_ZEROCOPY | UCL_PARSER_NO_IMPLICIT_ARRAYS);
			ucl_parser_add_chunk(
			  p, reinterpret_cast<unsigned char *>(data.data()), data.size());
			// FIXME: Error checking (should be impossible here, but who knows
			// with a remote API)
			m = AzureInstance{ucl_parser_get_object(p)};
		}

		/**
		 * Expose the parsed object via arrow access.
		 */
		AzureInstance *operator->()
		{
			return &m;
		}
	};

} // namespace

int main()
{
	{
		AzureInstanceMetadata m;
		std::cout << "azure_resource_disk_size=\"" << m->compute().storageProfile().resourceDisk().size() << '"' << std::endl;
		std::cout << "azure_admin_user_name=\"" << m->compute().osProfile().adminUsername() << '"' << std::endl;
		std::cout << "azure_computer_name=\"" << m->compute().osProfile().computerName() << '"' << std::endl;
		std::cout << "azure_password_auth_disabled=\"" << m->compute().osProfile().disablePasswordAuthentication() << '"' << std::endl;
		int i = 0;
		for (auto k : m->compute().publicKeys())
		{
			std::cout << "azure_ssh_key_data_" << i << "=\"" << k.keyData() << '"' << std::endl;
			std::cout << "azure_ssh_key_path_" << i << "=\"" << k.path() << '"' << std::endl;
		}
	}
	// Test code for getting the scheduled events status.  Eventually we may
	// want to poll this once per second and do things with it.
	if (0)
	{
		HTTPClient con{"169.254.169.254"};
		std::array<std::pair<const char *, const char *>, 1> header{
		  std::make_pair("Metadata", "true")};
		std::vector<char> data;
		con.get("/metadata/scheduledevents?api-version=2020-07-01",
		        header)([&](auto &buffer) { data = std::move(buffer); },
		                [](auto &err) {
			                std::cerr << "Error " << err.error_code << " "
			                          << err.error_message << std::endl;
			                exit(EXIT_FAILURE);
		                });
		std::cerr << "Received data: " << std::endl;
		for (auto c : data)
		{
			std::cerr << c;
		}
		std::cerr << std::endl;
	}
}
